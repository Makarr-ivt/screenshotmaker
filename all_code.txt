--- CMakeLists.txt ---

cmake_minimum_required(VERSION 3.16)
project(screenshotmaker VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)

find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS Widgets)

set(CORE_SOURCES
    core/screenshotcontext.cpp
)

set(CAPTURE_SOURCES
    capture/fullscreencapturestrategy.cpp
    capture/rectanglecapturestrategy.cpp
    capture/capturemanager.cpp
)

set(SERVICES_SOURCES
    services/fileexportservice.cpp
    services/clipboardservice.cpp
    services/imageprocessingservice.cpp
)

# Новые UI файлы для захвата области
set(UI_SOURCES
    ui/rectanglesselectionoverlay.cpp
    ui/selectionvisualizer.cpp
)

# Все исходные файлы
set(SOURCES
    main.cpp
    mainwindow.cpp
    ${CORE_SOURCES}
    ${CAPTURE_SOURCES}
    ${SERVICES_SOURCES}
    ${UI_SOURCES}
)

set(CORE_HEADERS
    core/screenshotcontext.h
    core/editcommand.h
)

set(CAPTURE_HEADERS
    capture/icapturestrategy.h
    capture/fullscreencapturestrategy.h
    capture/rectanglecapturestrategy.h
    capture/capturemanager.h
)

set(SERVICES_HEADERS
    services/fileexportservice.h
    services/clipboardservice.h
    services/imageprocessingservice.h
)

set(UI_HEADERS
    ui/rectanglesselectionoverlay.h
    ui/selectionvisualizer.h
)

set(HEADERS
    mainwindow.h
    ${CORE_HEADERS}
    ${CAPTURE_HEADERS}
    ${SERVICES_HEADERS}
    ${UI_HEADERS}
)

set(FORMS
    mainwindow.ui
)

add_executable(screenshotmaker ${SOURCES} ${HEADERS} ${FORMS})
target_link_libraries(screenshotmaker PRIVATE Qt${QT_VERSION_MAJOR}::Widgets)

if(WIN32)
    set_target_properties(screenshotmaker PROPERTIES WIN32_EXECUTABLE TRUE)
endif()

# Устанавливаем выходной каталог
set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)

---
--- main.cpp ---

#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}

---
--- mainwindow.h ---

#pragma once

#include <QMainWindow>
#include <QRect>

#include "core/screenshotcontext.h"
#include "capture/capturemanager.h"
#include "services/fileexportservice.h"
#include "services/clipboardservice.h"

QT_BEGIN_NAMESPACE
namespace Ui {
class MainWindow;
}
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void on_captureFullScreenButton_clicked();
    void on_captureAreaButton_clicked();
    void on_saveButton_clicked();
    void on_exitButton_clicked();
    void on_copyToClipboardButton_clicked();

    void onScreenshotContextChanged();

private:
    Ui::MainWindow *ui;

    // Новая архитектура - полная замена ScreenshotCapturer
    ScreenshotContext m_screenshotContext;
    CaptureManager m_captureManager;
    FileExportService m_fileExportService;
    ClipboardService m_clipboardService;

    // Для захвата области
    void startAreaSelection();
    void completeAreaSelection(const QRect &area);
    void showMainWindow();

    // Временное состояние для захвата области
    QRect m_lastWindowGeometry;
    bool m_wasMaximized = false;
    QPixmap m_fullScreenShot;  // Добавляем это поле для хранения скриншота ДО показа оверлея

    void updateUI();
    void updateScreenshotDisplay();
    void updateInfoLabel();
    void updateButtonStates();

protected:
    void resizeEvent(QResizeEvent *event) override;
};

---
--- mainwindow.cpp ---

#include "mainwindow.h"
#include "ui_mainwindow.h"

// Стандартные Qt заголовки
#include <QThread>
#include <QTimer>
#include <QResizeEvent>
#include <QGuiApplication>
#include <QFileDialog>
#include <QMessageBox>
#include <QDateTime>
#include <QDir>
#include <QScreen>
#include <QShortcut>

// Заголовки новой архитектуры
#include "capture/fullscreencapturestrategy.h"
#include "capture/rectanglecapturestrategy.h"
#include "ui/rectanglesselectionoverlay.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // Подключаем сигналы новой архитектуры
    connect(&m_screenshotContext, &ScreenshotContext::imageChanged,
            this, &MainWindow::onScreenshotContextChanged);

    updateUI();

    // Подключаем кнопку выхода
    connect(ui->exitButton, &QPushButton::clicked, this, &MainWindow::close);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_captureFullScreenButton_clicked()
{
    // Сохраняем состояние окна перед скрытием
    bool wasMaximized = this->isMaximized();
    QRect originalGeometry = this->geometry();

    // Скрываем окно на время захвата
    this->hide();

    // Даем время окну скрыться
    QThread::msleep(200);

    // Захватываем экран с использованием новой архитектуры
    m_captureManager.setStrategy(std::make_unique<FullScreenCaptureStrategy>());
    QPixmap screenshot = m_captureManager.capture();
    m_screenshotContext.setImage(screenshot);

    // Показываем окно обратно
    this->show();

    // Восстанавливаем состояние окна
    if (wasMaximized) {
        this->showMaximized();
    } else {
        this->setGeometry(originalGeometry);
    }

    // Если скриншот удался, обновляем UI
    if (m_screenshotContext.hasImage()) {
        // Временно меняем заголовок для обратной связи
        this->setWindowTitle("ScreenshotMaker - Захвачено!");
        QTimer::singleShot(1500, this, [this]() {
            this->setWindowTitle("ScreenshotMaker");
        });
    } else {
        // Обработка ошибки
        ui->screenshotLabel->setText("Ошибка захвата экрана");
        ui->screenshotLabel->setAlignment(Qt::AlignCenter);
    }
}

void MainWindow::on_captureAreaButton_clicked()
{
    startAreaSelection();
}

void MainWindow::startAreaSelection()
{
    // Сохраняем состояние окна
    m_wasMaximized = this->isMaximized();
    m_lastWindowGeometry = this->geometry();

    // Скрываем главное окно
    this->hide();

    // Ждем, чтобы окно успело скрыться
    QTimer::singleShot(100, this, [this]() {
        // Делаем скриншот всего экрана ДО показа оверлея
        m_captureManager.setStrategy(std::make_unique<FullScreenCaptureStrategy>());
        m_fullScreenShot = m_captureManager.capture();

        if (m_fullScreenShot.isNull()) {
            QMessageBox::warning(this, "Ошибка", "Не удалось сделать снимок экрана.");
            showMainWindow();
            return;
        }

        // Создаем и показываем оверлей
        RectangleSelectionOverlay *overlay = new RectangleSelectionOverlay();
        overlay->setAttribute(Qt::WA_DeleteOnClose);

        // Подключаем сигналы оверлея
        connect(overlay, &RectangleSelectionOverlay::selectionCompleted,
                this, [this](const QRect &area) {
                    completeAreaSelection(area);
                });

        connect(overlay, &RectangleSelectionOverlay::selectionCancelled,
                this, &MainWindow::showMainWindow);

        // Гарантируем показ главного окна при любом исходе
        connect(overlay, &QObject::destroyed, this, &MainWindow::showMainWindow);

        // Показываем оверлей
        overlay->showFullScreen();
    });
}

void MainWindow::completeAreaSelection(const QRect &area)
{
    if (area.isValid() && area.width() > 10 && area.height() > 10) {
        // Получаем primary screen
        QScreen *primaryScreen = QGuiApplication::primaryScreen();
        if (!primaryScreen) {
            QMessageBox::warning(this, "Ошибка", "Не удалось получить экран.");
            showMainWindow();
            return;
        }

        // Учитываем device pixel ratio (для HiDPI экранов)
        qreal dpr = primaryScreen->devicePixelRatio();

        // Конвертируем координаты с учетом DPI
        QRect scaledArea(
            qRound(area.x() * dpr),
            qRound(area.y() * dpr),
            qRound(area.width() * dpr),
            qRound(area.height() * dpr)
            );

        // Вырезаем область из скриншота
        if (scaledArea.intersected(m_fullScreenShot.rect()).isValid()) {
            QPixmap areaScreenshot = m_fullScreenShot.copy(scaledArea);

            if (!areaScreenshot.isNull()) {
                // Масштабируем обратно для отображения
                areaScreenshot.setDevicePixelRatio(dpr);
                m_screenshotContext.setImage(areaScreenshot);

                this->setWindowTitle("ScreenshotMaker - Область захвачена!");
                QTimer::singleShot(1500, this, [this]() {
                    this->setWindowTitle("ScreenshotMaker");
                });
            } else {
                QMessageBox::warning(this, "Ошибка", "Не удалось вырезать выбранную область.");
            }
        } else {
            QMessageBox::warning(this, "Ошибка", "Выбранная область вне границ экрана.");
        }
    } else {
        QMessageBox::warning(this, "Некорректная область",
                             "Выделенная область слишком мала или некорректна.");
    }

    showMainWindow();
}

void MainWindow::showMainWindow()
{
    // Показываем главное окно
    this->show();

    // Восстанавливаем состояние окна
    if (m_wasMaximized) {
        this->showMaximized();
    } else {
        this->setGeometry(m_lastWindowGeometry);
    }

    // Делаем окно активным
    this->activateWindow();
    this->raise();
}

void MainWindow::on_saveButton_clicked()
{
    // Проверяем, есть ли скриншот для сохранения
    if (!m_screenshotContext.hasImage()) {
        QMessageBox::warning(this,
                             "Нет скриншота",
                             "Сначала сделайте скриншот, чтобы сохранить его.");
        return;
    }

    // Генерируем имя файла по умолчанию с датой и временем
    QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd_HH-mm-ss");
    QString defaultFileName = QDir::homePath() + "/Снимок_" + timestamp + ".png";

    // Открываем диалог сохранения файла
    QString fileName = QFileDialog::getSaveFileName(
        this,                                      // родительское окно
        "Сохранить скриншот",                     // заголовок
        defaultFileName,                          // начальный путь
        m_fileExportService.formatFilter()        // фильтры из сервиса
        );

    // Если пользователь выбрал файл (не нажал "Отмена")
    if (!fileName.isEmpty()) {
        // Пытаемся сохранить
        bool success = m_fileExportService.saveToFile(m_screenshotContext.image(), fileName);

        if (success) {
            // Успех - показываем сообщение
            QMessageBox::information(this, "Успешно", QString("Скриншот сохранен в:\n%1").arg(fileName));

            // Визуальная обратная связь
            QString originalText = ui->saveButton->text();
            ui->saveButton->setText("Сохранено!");

            // Через секунду возвращаем оригинальный текст
            QTimer::singleShot(1000, this, [this, originalText]() {
                ui->saveButton->setText(originalText);
            });
        } else {
            QMessageBox::critical(this, "Ошибка", "Не удалось сохранить файл.");
        }
    }
}

void MainWindow::on_exitButton_clicked()
{
    close();
}

void MainWindow::on_copyToClipboardButton_clicked()
{
    // Проверяем, есть ли скриншот
    if (!m_screenshotContext.hasImage()) {
        QMessageBox msgBox;
        msgBox.setIcon(QMessageBox::Warning);
        msgBox.setWindowTitle("Нет скриншота");
        msgBox.setText("Сначала сделайте скриншот.");
        msgBox.exec();
        return;
    }

    // Копируем с использованием сервиса
    m_clipboardService.copyToClipboard(m_screenshotContext.image());

    // Визуальная обратная связь
    ui->copyToClipboardButton->setText("Скопировано!");
    QTimer::singleShot(1000, this, [this]() {
        ui->copyToClipboardButton->setText("Копировать в буфер");
    });
}

void MainWindow::onScreenshotContextChanged()
{
    updateScreenshotDisplay();
    updateInfoLabel();
    updateButtonStates();
}

void MainWindow::updateUI()
{
    // Изначально кнопки действий отключены
    ui->saveButton->setEnabled(false);
    ui->copyToClipboardButton->setEnabled(false);

    // Активируем кнопку выбора области
    ui->captureAreaButton->setEnabled(true);

    // Устанавливаем начальный текст
    ui->screenshotLabel->setText("Нажмите 'Весь экран' для захвата");
    ui->screenshotLabel->setAlignment(Qt::AlignCenter);

    updateInfoLabel();
    updateButtonStates();
}

void MainWindow::updateScreenshotDisplay()
{
    if (!m_screenshotContext.hasImage()) {
        return;
    }

    // Получаем размер метки
    QSize labelSize = ui->screenshotLabel->size();

    // Масштабируем изображение, сохраняя пропорции
    QPixmap scaledPixmap = m_screenshotContext.image().scaled(
        labelSize,
        Qt::KeepAspectRatio,
        Qt::SmoothTransformation
        );

    // Отображаем скриншот
    ui->screenshotLabel->setPixmap(scaledPixmap);
    ui->screenshotLabel->setText("");
}

void MainWindow::updateInfoLabel()
{
    if (m_screenshotContext.hasImage()) {
        QString info = QString("Размер: %1×%2")
                           .arg(m_screenshotContext.image().width())
                           .arg(m_screenshotContext.image().height());
        ui->infoLabel->setText(info);
    } else {
        ui->infoLabel->setText("Размер: 0×0");
    }
}

void MainWindow::updateButtonStates()
{
    bool hasImage = m_screenshotContext.hasImage();
    ui->saveButton->setEnabled(hasImage);
    ui->copyToClipboardButton->setEnabled(hasImage);
}

// Добавляем обработчик изменения размера окна
void MainWindow::resizeEvent(QResizeEvent *event)
{
    QMainWindow::resizeEvent(event);
    updateScreenshotDisplay();
}

---
--- capture/icapturestrategy.h ---
#pragma once

#include <QPixmap>

class ICaptureStrategy
{
public:
    virtual ~ICaptureStrategy() = default;
    virtual QPixmap capture() = 0;
    virtual QString name() const = 0;
};

---
--- capture/capturemanager.h ---

#pragma once

#include "icapturestrategy.h"
#include <memory>

class CaptureManager
{
public:
    CaptureManager();
    
    void setStrategy(std::unique_ptr<ICaptureStrategy> strategy);
    QPixmap capture();
    QString currentStrategyName() const;
    
private:
    std::unique_ptr<ICaptureStrategy> m_strategy;
};

---
--- capture/capturemanager.cpp ---

#include "capturemanager.h"

CaptureManager::CaptureManager()
{
}

void CaptureManager::setStrategy(std::unique_ptr<ICaptureStrategy> strategy)
{
    m_strategy = std::move(strategy);
}

QPixmap CaptureManager::capture()
{
    if (m_strategy) {
        return m_strategy->capture();
    }
    return QPixmap();
}

QString CaptureManager::currentStrategyName() const
{
    if (m_strategy) {
        return m_strategy->name();
    }
    return "Не выбрана";
}

---
--- capture/fullscreencapturestrategy.h ---
#pragma once

#include "icapturestrategy.h"

class FullScreenCaptureStrategy : public ICaptureStrategy
{
public:
    QPixmap capture() override;
    QString name() const override { return "Полный экран"; }
};

---
--- capture/fullscreencapturestrategy.cpp ---

#include "fullscreencapturestrategy.h"
#include <QGuiApplication>
#include <QScreen>

QPixmap FullScreenCaptureStrategy::capture()
{
    QScreen *screen = QGuiApplication::primaryScreen();
    if (screen) {
        return screen->grabWindow(0);
    }
    return QPixmap();
}

---
--- capture/rectanglecapturestrategy.h ---

#pragma once

#include "icapturestrategy.h"
#include <QRect>

class RectangleCaptureStrategy : public ICaptureStrategy
{
public:
    RectangleCaptureStrategy(const QRect &area);
    QPixmap capture() override;
    QString name() const override { return "Прямоугольная область"; }
    
private:
    QRect m_area;
};

---
--- capture/rectanglecapturestrategy.cpp ---

#include "rectanglecapturestrategy.h"
#include <QGuiApplication>
#include <QScreen>

RectangleCaptureStrategy::RectangleCaptureStrategy(const QRect &area)
    : m_area(area)
{
}

QPixmap RectangleCaptureStrategy::capture()
{
        // Эта стратегия больше не используется напрямую
        // Вместо нее используем вырезание из m_fullScreenShot
        return QPixmap();
}

---
--- core/screenshotcontext.h ---
#pragma once

#include <QPixmap>
#include <QObject>
#include <memory>
#include <stack>

class EditCommand;

class ScreenshotContext : public QObject
{
    Q_OBJECT

public:
    explicit ScreenshotContext(QObject *parent = nullptr);
    ~ScreenshotContext();

    void setImage(const QPixmap &image);
    const QPixmap& image() const;
    QPixmap& imageRef();
    bool hasImage() const;

    void applyEdit(std::unique_ptr<EditCommand> command);
    bool canUndo() const;
    bool canRedo() const;
    void undo();
    void redo();
    void clearHistory();

signals:
    void imageChanged(const QPixmap &newImage);
    void canUndoChanged(bool canUndo);
    void canRedoChanged(bool canRedo);

private:
    QPixmap m_image;
    std::stack<std::unique_ptr<EditCommand>> m_undoStack;
    std::stack<std::unique_ptr<EditCommand>> m_redoStack;
};

---
--- core/screenshotcontext.cpp ---

#include "screenshotcontext.h"
#include "editcommand.h"

ScreenshotContext::ScreenshotContext(QObject *parent)
    : QObject(parent)
{
}

ScreenshotContext::~ScreenshotContext()
{
    clearHistory();
}

void ScreenshotContext::setImage(const QPixmap &image)
{
    if (m_image.cacheKey() == image.cacheKey())
        return;

    m_image = image;
    clearHistory();
    emit imageChanged(m_image);
}

const QPixmap &ScreenshotContext::image() const
{
    return m_image;
}

QPixmap &ScreenshotContext::imageRef()
{
    return m_image;
}

bool ScreenshotContext::hasImage() const
{
    return !m_image.isNull();
}

void ScreenshotContext::applyEdit(std::unique_ptr<EditCommand> command)
{
    if (!command)
        return;

    command->execute(m_image);
    m_undoStack.push(std::move(command));
    m_redoStack = std::stack<std::unique_ptr<EditCommand>>();

    emit canUndoChanged(true);
    emit canRedoChanged(false);
    emit imageChanged(m_image);
}

bool ScreenshotContext::canUndo() const
{
    return !m_undoStack.empty();
}

bool ScreenshotContext::canRedo() const
{
    return !m_redoStack.empty();
}

void ScreenshotContext::undo()
{
    if (m_undoStack.empty())
        return;

    auto command = std::move(m_undoStack.top());
    m_undoStack.pop();
    command->undo(m_image);
    m_redoStack.push(std::move(command));

    emit canUndoChanged(!m_undoStack.empty());
    emit canRedoChanged(true);
    emit imageChanged(m_image);
}

void ScreenshotContext::redo()
{
    if (m_redoStack.empty())
        return;

    auto command = std::move(m_redoStack.top());
    m_redoStack.pop();
    command->execute(m_image);
    m_undoStack.push(std::move(command));

    emit canUndoChanged(true);
    emit canRedoChanged(!m_redoStack.empty());
    emit imageChanged(m_image);
}

void ScreenshotContext::clearHistory()
{
    while (!m_undoStack.empty())
        m_undoStack.pop();
    while (!m_redoStack.empty())
        m_redoStack.pop();

    emit canUndoChanged(false);
    emit canRedoChanged(false);
}

---
--- core/editcommand.h ---

#pragma once

#include <QPixmap>
#include <memory>

class EditCommand
{
public:
    virtual ~EditCommand() = default;
    
    virtual void execute(QPixmap &image) = 0;
    virtual void undo(QPixmap &image) = 0;
    virtual QString description() const = 0;
    
protected:
    QPixmap m_originalState;
    QPixmap m_modifiedState;
};

---
--- services/imageprocessingservice.h ---

#pragma once

#include <QPixmap>
#include <QRect>

class ImageProcessingService
{
public:
    ImageProcessingService() = default;
    
    QPixmap crop(const QPixmap &image, const QRect &rect);
    QPixmap scale(const QPixmap &image, const QSize &size, bool keepAspectRatio = true);
    QPixmap addText(const QPixmap &image, const QString &text, const QPoint &position);
    QPixmap drawLine(const QPixmap &image, const QPoint &from, const QPoint &to);
    
    QString getImageInfo(const QPixmap &image) const;
};

---
--- services/imageprocessingservice.cpp ---

#include "imageprocessingservice.h"
#include <QPainter>

QPixmap ImageProcessingService::crop(const QPixmap &image, const QRect &rect)
{
    if (image.isNull() || !rect.isValid())
        return QPixmap();
        
    return image.copy(rect);
}

QPixmap ImageProcessingService::scale(const QPixmap &image, const QSize &size, bool keepAspectRatio)
{
    if (image.isNull())
        return QPixmap();
        
    Qt::AspectRatioMode mode = keepAspectRatio ? Qt::KeepAspectRatio : Qt::IgnoreAspectRatio;
    return image.scaled(size, mode, Qt::SmoothTransformation);
}

QPixmap ImageProcessingService::addText(const QPixmap &image, const QString &text, const QPoint &position)
{
    if (image.isNull() || text.isEmpty())
        return image;
        
    QPixmap result = image;
    QPainter painter(&result);
    painter.setPen(Qt::red);
    painter.setFont(QFont("Arial", 14));
    painter.drawText(position, text);
    
    return result;
}

QPixmap ImageProcessingService::drawLine(const QPixmap &image, const QPoint &from, const QPoint &to)
{
    if (image.isNull())
        return QPixmap();
        
    QPixmap result = image;
    QPainter painter(&result);
    painter.setPen(QPen(Qt::red, 2));
    painter.drawLine(from, to);
    
    return result;
}

QString ImageProcessingService::getImageInfo(const QPixmap &image) const
{
    if (image.isNull())
        return QString("Размер: 0×0");
        
    return QString("Размер: %1×%2").arg(image.width()).arg(image.height());
}

---
--- services/clipboardservice.h ---

#pragma once

#include <QPixmap>
#include <QObject>

class ClipboardService : public QObject
{
    Q_OBJECT

public:
    explicit ClipboardService(QObject *parent = nullptr);
    
    void copyToClipboard(const QPixmap &image);
    bool hasImage() const;
    QPixmap pasteFromClipboard() const;
    
signals:
    void clipboardChanged();
};

---
--- services/clipboardservice.cpp ---

#include "clipboardservice.h"
#include <QGuiApplication>
#include <QClipboard>
#include <QMimeData>

ClipboardService::ClipboardService(QObject *parent)
    : QObject(parent)
{
    connect(QGuiApplication::clipboard(), &QClipboard::dataChanged,
            this, &ClipboardService::clipboardChanged);
}

void ClipboardService::copyToClipboard(const QPixmap &image)
{
    if (image.isNull())
        return;
        
    QClipboard *clipboard = QGuiApplication::clipboard();
    clipboard->setPixmap(image);
}

bool ClipboardService::hasImage() const
{
    QClipboard *clipboard = QGuiApplication::clipboard();
    return clipboard->mimeData()->hasImage();
}

QPixmap ClipboardService::pasteFromClipboard() const
{
    QClipboard *clipboard = QGuiApplication::clipboard();
    return clipboard->pixmap();
}


---
--- services/fileexportservice.h ---

#pragma once

#include <QPixmap>
#include <QString>

class FileExportService
{
public:
    FileExportService() = default;
    
    bool saveToFile(const QPixmap &image, const QString &filePath);
    QStringList supportedFormats() const;
    QString formatFilter() const;
    
private:
    QString getFormatFromExtension(const QString &filePath) const;
};

---
--- services/fileexportservice.cpp ---

#include "fileexportservice.h"
#include <QFileInfo>
#include <QMap>

bool FileExportService::saveToFile(const QPixmap &image, const QString &filePath)
{
    if (image.isNull() || filePath.isEmpty())
        return false;

    QString format = getFormatFromExtension(filePath);
    return image.save(filePath, format.toUtf8().constData());
}

QStringList FileExportService::supportedFormats() const
{
    return {"png", "jpg", "jpeg", "bmp"};
}

QString FileExportService::formatFilter() const
{
    QStringList filters;
    filters << "PNG (*.png)";
    filters << "JPEG (*.jpg *.jpeg)";
    filters << "BMP (*.bmp)";
    filters << "All Files (*.*)";
    
    return filters.join(";;");
}

QString FileExportService::getFormatFromExtension(const QString &filePath) const
{
    QFileInfo info(filePath);
    QString extension = info.suffix().toLower();
    
    static const QMap<QString, QString> formatMap = {
        {"jpg", "JPG"},
        {"jpeg", "JPG"},
        {"png", "PNG"},
        {"bmp", "BMP"}
    };
    
    return formatMap.value(extension, "PNG");
}

---
--- ui/rectangleselectionoverlay.h ---

#pragma once

#include <QWidget>
#include <QPainter>
#include <QMouseEvent>
#include <QApplication>
#include <QScreen>

class RectangleSelectionOverlay : public QWidget
{
    Q_OBJECT

public:
    explicit RectangleSelectionOverlay(QWidget *parent = nullptr);
    ~RectangleSelectionOverlay() override = default;

    QRect selectedRect() const { return m_selectionRect.normalized(); }

signals:
    void selectionCompleted(const QRect &rect);
    void selectionCancelled();

protected:
    void paintEvent(QPaintEvent *event) override;
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    void keyPressEvent(QKeyEvent *event) override;

private:
    void updateCursor();
    void captureSelection();

    QRect m_selectionRect;
    QPoint m_startPoint;
    bool m_isSelecting = false;
    
    const QColor m_selectionColor = QColor(0, 120, 215, 100);
    const QColor m_borderColor = QColor(0, 120, 215);
    const int m_borderWidth = 2;
};

---
--- ui/rectangleselectionoverlay.cpp ---

#include "rectanglesselectionoverlay.h"
#include <QPainter>
#include <QKeyEvent>
#include <QGuiApplication>

RectangleSelectionOverlay::RectangleSelectionOverlay(QWidget *parent)
    : QWidget(parent)
{
    // Настройки окна
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool);
    setAttribute(Qt::WA_TranslucentBackground);
    setMouseTracking(true);
    
    // Захватываем весь экран
    QScreen *primaryScreen = QGuiApplication::primaryScreen();
    if (primaryScreen) {
        setGeometry(primaryScreen->geometry());
    }
    
    setCursor(Qt::CrossCursor);
}

void RectangleSelectionOverlay::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
    
    // Полупрозрачный темный фон
    painter.fillRect(rect(), QColor(0, 0, 0, 100));
    
    // Если идет выделение, рисуем прямоугольник
    if (m_isSelecting && !m_selectionRect.isNull()) {
        // Вырезаем выделенную область (прозрачная в центре)
        QRegion fullRegion(rect());
        QRegion selectedRegion(m_selectionRect);
        QRegion darkRegion = fullRegion.subtracted(selectedRegion);
        
        painter.setClipRegion(darkRegion);
        painter.fillRect(rect(), QColor(0, 0, 0, 150));
        painter.setClipping(false);
        
        // Рамка выделения
        painter.setPen(QPen(m_borderColor, m_borderWidth));
        painter.setBrush(m_selectionColor);
        painter.drawRect(m_selectionRect);
        
        // Размеры области
        QString sizeText = QString("%1×%2")
            .arg(m_selectionRect.width())
            .arg(m_selectionRect.height());
        
        painter.setPen(Qt::white);
        painter.setFont(QFont("Arial", 12, QFont::Bold));
        
        QRect textRect = m_selectionRect;
        textRect.setTop(textRect.top() - 30);
        textRect.setHeight(25);
        
        painter.drawText(textRect, Qt::AlignCenter, sizeText);
    }
}

void RectangleSelectionOverlay::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        m_startPoint = event->pos();  // Меняем globalPos() на pos()
        m_selectionRect = QRect(m_startPoint, QSize());
        m_isSelecting = true;
        update();
    }
}

void RectangleSelectionOverlay::mouseMoveEvent(QMouseEvent *event)
{
    if (m_isSelecting) {
        m_selectionRect = QRect(m_startPoint, event->pos()).normalized();  // Меняем globalPos() на pos()
        updateCursor();
        update();
    }
}

void RectangleSelectionOverlay::mouseReleaseEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton && m_isSelecting) {
        m_isSelecting = false;
        captureSelection();
    }
}

void RectangleSelectionOverlay::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_Escape) {
        emit selectionCancelled();
        close();
    } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
        if (!m_selectionRect.isNull()) {
            captureSelection();
        }
    }
}

void RectangleSelectionOverlay::updateCursor()
{
    if (m_selectionRect.isNull()) {
        setCursor(Qt::CrossCursor);
    } else {
        setCursor(Qt::ArrowCursor);
    }
}

void RectangleSelectionOverlay::captureSelection()
{
    if (!m_selectionRect.isNull()) {
        emit selectionCompleted(m_selectionRect.normalized());
    }
    close();
}


---
--- ui/selectionvizualizer.h ---

#pragma once

#include <QWidget>
#include <QPainter>

class SelectionVisualizer : public QWidget
{
    Q_OBJECT

public:
    explicit SelectionVisualizer(QWidget *parent = nullptr);
    
    void setSelectionRect(const QRect &rect);
    QRect selectionRect() const { return m_selectionRect; }

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    QRect m_selectionRect;
    const QColor m_selectionColor = QColor(0, 120, 215, 50);
    const QColor m_borderColor = QColor(0, 120, 215);
};

---
--- ui/selectionvizualizer.cpp ---

#include "selectionvisualizer.h"
#include <QPainter>

SelectionVisualizer::SelectionVisualizer(QWidget *parent)
    : QWidget(parent)
{
    setAttribute(Qt::WA_TransparentForMouseEvents);
    setAttribute(Qt::WA_TranslucentBackground);
}

void SelectionVisualizer::setSelectionRect(const QRect &rect)
{
    m_selectionRect = rect;
    update();
}

void SelectionVisualizer::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    
    if (m_selectionRect.isNull()) {
        return;
    }
    
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
    
    // Заливка
    painter.setBrush(m_selectionColor);
    painter.setPen(Qt::NoPen);
    painter.drawRect(m_selectionRect);
    
    // Рамка
    painter.setBrush(Qt::NoBrush);
    painter.setPen(QPen(m_borderColor, 2));
    painter.drawRect(m_selectionRect);
    
    // Размеры
    painter.setPen(Qt::white);
    painter.setFont(QFont("Arial", 10));
    QString sizeText = QString("%1 × %2")
        .arg(m_selectionRect.width())
        .arg(m_selectionRect.height());
    
    QRect textRect = m_selectionRect;
    textRect.setTop(textRect.top() - 25);
    textRect.setHeight(20);
    
    painter.drawText(textRect, Qt::AlignCenter, sizeText);
}